/*
 * Copyright (C) OpenTX
 *
 * Based on code named
 *   th9x - http://code.google.com/p/th9x
 *   er9x - http://code.google.com/p/er9x
 *   gruvin9x - http://code.google.com/p/gruvin9x
 *
 * License GPLv2: http://www.gnu.org/licenses/gpl-2.0.html
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#include "opentx.h"

// Resolve clash with libopencm3 defines

#undef FLASH_BASE
#undef PERIPH_BASE
#undef I2C1_BASE
#undef I2C2_BASE
#undef I2C1
#undef I2C2
#undef I2C_CR1_PECEN
#undef I2C_CR1_ALERTEN
#undef I2C_CR1_SMBDEN
#undef I2C_CR1_SMBHEN
#undef I2C_CR1_GCEN
#undef I2C_CR1_WUPEN
#undef I2C_CR1_NOSTRETCH
#undef I2C_CR1_SBC
#undef I2C_CR1_RXDMAEN
#undef I2C_CR1_TXDMAEN
#undef I2C_CR1_ANFOFF
#undef I2C_CR1_ERRIE
#undef I2C_CR1_TCIE
#undef I2C_CR1_STOPIE
#undef I2C_CR1_NACKIE
#undef I2C_CR1_ADDRIE
#undef I2C_CR1_RXIE
#undef I2C_CR1_TXIE
#undef I2C_CR1_PE
#undef I2C_CR2_PECBYTE
#undef I2C_CR2_AUTOEND
#undef I2C_CR2_RELOAD
#undef I2C_CR2_NACK
#undef I2C_CR2_STOP
#undef I2C_CR2_START
#undef I2C_CR2_HEAD10R
#undef I2C_CR2_ADD10
#undef I2C_CR2_RD_WRN
#undef I2C_ISR_BUSY
#undef I2C_ISR_ALERT
#undef I2C_ISR_TIMEOUT
#undef I2C_ISR_PECERR
#undef I2C_ISR_OVR
#undef I2C_ISR_ARLO
#undef I2C_ISR_BERR
#undef I2C_ISR_TCR
#undef I2C_ISR_TC
#undef I2C_ISR_STOPF
#undef I2C_ISR_NACKF
#undef I2C_ISR_ADDR
#undef I2C_ISR_RXNE
#undef I2C_ISR_TXIS
#undef I2C_ISR_TXE
#undef I2C_ICR_ALERTCF
#undef I2C_ICR_TIMOUTCF
#undef I2C_ICR_PECCF
#undef I2C_ICR_OVRCF
#undef I2C_ICR_ARLOCF
#undef I2C_ICR_BERRCF
#undef I2C_ICR_STOPCF
#undef I2C_ICR_NACKCF
#undef I2C_ICR_ADDRCF

#include "i2c_common_v2.h"

#include <stdio.h>
#include <string.h>

#define sEE_FLAG_TIMEOUT ((uint32_t)0x1000)
#define sEE_LONG_TIMEOUT ((uint32_t)(10 * sEE_FLAG_TIMEOUT))
void sEE_TIMEOUT_UserCallback(void);
uint32_t sEETimeout = sEE_LONG_TIMEOUT;

/**
  * @brief  Basic management of the timeout situation.
  * @param  None.
  * @retval 0.
  */
void sEE_TIMEOUT_UserCallback(void)
{
  /* The following code allows I2C error recovery and return to normal communication
     if the error source doesnÂ’t still exist (ie. hardware issue..) */

  /* Reinitialize all resources */
  TRACE("Timeout!");
  eepromInit();

  /* At this stage the I2C error should be recovered and device can communicate
     again (except if the error source still exist).
     User can implement mechanism (ex. test on max trial number) to manage situation
     when the I2C can't recover from current error. */
}

void eepromInit()
{

  uint32_t i2c;

  i2c = I2C2;

  TRACE("eepromInit");
  i2c_reset(i2c);

  /* Disable the I2C before changing any configuration. */
  i2c_peripheral_disable(i2c);

  /* setup from libopencm3-examples */
  i2c_enable_analog_filter(i2c);
  i2c_set_digital_filter(i2c, 0);
  i2c_set_speed(i2c, i2c_speed_sm_100k, 8); // i2c_speed_fm_400k  i2c_speed_sm_100k
  i2c_enable_stretching(i2c);
  i2c_set_7bit_addr_mode(i2c);

  /* If everything is configured -> enable the peripheral. */
  i2c_peripheral_enable(i2c);
  TRACE("done");
}
void eepromStartRead(uint8_t *buffer, size_t address, size_t size)
{
  uint8_t wb[2];

  TRACE("eepromStartRead");
  size_t count = 0;
  uint8_t * pos = buffer;
  while (count < size)
  {
    wb[0] = (uint8_t)((address + count) >> 8);
    wb[1] = (uint8_t)((address + count) & 0xFF);
    
    //TRACE("pos %p count %d size %d addr %02X%02X", pos, count, size, wb[0], wb[1]);
    i2c_transfer7(I2C2, I2C_ADDRESS_EEPROM, wb, 2, pos++, 1);
    count++;
  }

  TRACE("eepromStartRead done");
  DUMP(buffer, size);
}

void eepromPageWrite(uint8_t *pBuffer, uint16_t WriteAddr, uint8_t NumByteToWrite)
{
  TRACE("eepromPageWrite");
  uint8_t wb[2];
  wb[0] = (uint8_t)(WriteAddr >> 8);
  wb[1] = (uint8_t)(WriteAddr & 0xFF);
  uint8_t temp[2 + EEPROM_PAGE_SIZE];
  memcpy(temp, wb, 2);
  memcpy(temp + 2, pBuffer, NumByteToWrite);
  DUMP(temp, NumByteToWrite + 2);
  i2c_transfer7(I2C2, I2C_ADDRESS_EEPROM, pBuffer, NumByteToWrite + 2, NULL, 0);
  TRACE("Write done");
}
void eepromStartWrite(uint8_t *buffer, size_t address, size_t size)
{
  TRACE("eepromStartWrite");
  uint8_t offset = address % EEPROM_PAGE_SIZE;
  uint8_t count = EEPROM_PAGE_SIZE - offset;
  if (size < count)
  {
    count = size;
  }
  while (count > 0)
  {
    eepromPageWrite(buffer, address, count);
    sEETimeout = sEE_LONG_TIMEOUT;
    while (I2C_GetFlagStatus(((I2C_TypeDef *)I2C2_BASE), I2C_ISR_STOPF) == RESET)
    {
      if ((sEETimeout--) == 0)
        sEE_TIMEOUT_UserCallback();
    }

    // while (!i2c_transfer_complete(I2C2))
    //   ;

    address += count;
    buffer += count;
    size -= count;
    count = EEPROM_PAGE_SIZE;
    if (size < EEPROM_PAGE_SIZE)
    {
      count = size;
    }
  }
  TRACE("eepromStartWrite done");
}
void eepromBlockErase(uint32_t address)
{
  TRACE("eepromBlockErase");
  static uint8_t erasedBlock[EEPROM_BLOCK_SIZE]; // can't be on the stack!
  memset(erasedBlock, 0xFF, sizeof(erasedBlock));
  eepromStartWrite(erasedBlock, address, EEPROM_BLOCK_SIZE);
  TRACE("done");
}
uint8_t eepromReadStatus()
{
  return 1;
}
uint8_t eepromIsTransferComplete()
{
  return 1;
}
